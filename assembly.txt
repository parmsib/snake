;kartan består av 32*32 bitar, där varje bit bestämmer om det är ett hinder i den cellen.
;32 * 32 bitar = 1024 bitar = 64 words

;var äpplet befinner sig bestäms av en word som beskriver X, och Y. 

;krävs en word för att bestämma en cell (5 bitar för X, 5 bitar för Y. 2^5 = 32)
;varje orm har en cirkulär array av celler den ockuperar, eller har ockuperat.
;finns en head, och en tail, för varje orm som beskriver var i arrayen ormen börjar, och var den slutar.
;en orm kan vara max 62 celler lång, så arrayen är 64 words (två extra för head och tail)

;menyn behöver en statisk bild att visa. Den är 32*32*4 bitar stor = 256 words

;karta över PM:
;programmet börjar på 0 och växer neråt
;Score ligger på $AFD
;Orm1 föregående håll ligger på $AFE
;Orm2 föregående håll ligger på $AFF
;menybild ligger på minesadress $B00 - $BFF
;orm1 ligger på minnesadress $C00 - $C3F = 3072 - 3135
;orm2 ligger på minnesadress $C40 - C7F = 3136 - 3199
;kartan ligger på minnesadress $C80 - $CBF = 3200 - 3263
;äpplet ligger på minnesadress $CC0 = 3264
;spelhastigheten ligger på minssadress $CC1 = 3265
;random minne för implementationer läggs på $D00 - slut = 3328 - slut

;Tiles:
;	0000 = 0, tomt
;   1111 = F, hinder
;   0010 = 2, orm1
;	0011 = 3, orm2
;	0100 = 4, äpple

;menyn fungerar så att joystick1 bestämmer spelhastighet med antingen höger, vänster, upp eller ner. Därefter går vi direkt till spelet

;---------------------------------------MENU-DELEN-------------------

MENU
	MLOAD #0, Gr0; ladda in 0 som startvärde för x
	MLOAD #0, Gr1; ladda in 0 som startvärde för y

MENULOOPX
	STORE $D00, Gr1, 0; kopiera data från Gr1 (y) till Gr15, som ska användas för att indexera GMEM
	LOAD $D00, Gr15, 0; 
	LSL #5, Gr15;shifta bort värdet till Y-delen av Gmem-adressen
	STORE $D00, Gr0, 0; ORa in data till X-delen av Gmem-adressen från Gr0 (x)
	OR $D00, Gr15;
	;Nu innehåller Gr15 Y-adressen konkatenerat med X-adressen, redo för GMEM
	
	;Behöver indexera minnesrymden som innehåller menybilden.
	STORE $D00, Gr1, 0; Lägg y * (32bitar = 8 words) i Gr2 som är word-index i statiska bilden
	LOAD $D00, Gr2;
	MUL #8, Gr2;
	STORE $D00, Gr0, 0; Lägg till x // 4 till Gr2, för att få rätt word-offset i x-led
	LOAD $D00, Gr3; 
	DIV #4, Gr3; heltalsdivision (avrunda nedåt)
	STORE $D00, Gr3;
	ADD $D00, Gr2;
	;nu innehåller Gr2 hela adressen till det word som vår sökta tile ligger i
	
	;behöver ta reda på vilken tile i detta word vi är ute efter
	STORE $D00, Gr0; Spara (x mod 4) - 1 till Gr3, vilket är tile-index i wordet
	LOAD $D00, Gr3;
	MOD #4, Gr3;
	SUB #1, Gr3;
	;nu innehåller Gr3 tile-index i wordet
	
	LOAD $B00, Gr4, Gr4; Ladda in rätt word från bilden till register 3
	MUL #4, Gr3; multiplicera tile-index för att få hur långt vi måste shifta i wordet
	LSL Gr3, Gr4; Shifta wordet så att vår tile hamnar längs till vänster (MSBs, vilket är vad GMEMet tar från bussen)
	AND Gr4, #$F000; ANDa bort de bitar som lång efter vår tile i wordet
	
	;Nu innehåller Gr4 den tile som ska ut på bussen och in i GMEM! :D
	;Gr15 innehåller den adress i GMEM som tilen ska sparas på, vilket är enligt överenskommelse.
	GSTORE Gr4;
	
	ADD #1, Gr0;
	CMP #32, Gr0;
	BEQ #MENULOOPY; om vi har loopat genm en hel rad, gå till nästa y
	BRA #MENULOOPX; annars, fortsätt på denna rad
	
MENULOOPY
	ADD #1, Gr1;
	CMP #32, Gr1;
	BEQ #MENULOOP; har vi loopat genom alla rader har vi printat hela bilden och kan gå vidare
	
	BRA #MENULOOPX; annars, fortsätt på nästa rad
	
	
MENULOOP
	;ladda in data från joystick1 till $D00 = 3328 i minnet
	;TODO ovan
	
	;kolla om det är under eller över threshhold för att gå vidare
	
	;ladda joysticks första word för jämförelse
	MLOAD #$D00, Gr0, 0 ;TODO kolla upp syntax o sånt
	CMP #NÅTTHRESHHOLD, Gr0 ;kolla om vi är över gränsen för att faktiskt räknas som ett val
	BLT #LEFTDIRSPEED
	
	;TODO: fortsätt åt andra håll

LEFTDIRSPEED
	MSTORE #$CC1, #NÅNHASTIGHET; lägg in en hastighet på rätt minnesplats
	BRA #UART
UPDIRSPEED
RIGHTDIRSPEED
DOWNDIRSPEED

;-------------------------------------------UART-DELEN----------------
	
UART
	;kartan består av 64 words. vi hämtar dem och räknar upp varje gång
	LOAD #0, Gr0;
UARTLOOP
	BOU #UARTREADY ;kolla om uart har ett word redo att hämtas
	BRA #UARTLOOP ;fortsätt vänta
UARTREADY
	;TODO: Gör nedanstående instruktion
	LOADUART Gr1; ladda Uart-wordet till Gr1
	STORE #$C80, Gr1, Gr0; Lägg till wordet på rätt ställe. använder Gr0 som index
	ADD #1, Gr0; incrementera countern
	CMP Gr0, #64; kolla om vi är färdiga
	BEQ #GAME; isf, hoppa till spelet
	BRA #UARTLOOP; annars, fortsätt leta words
	
;-----------------------------------GAME INIT-----------------------------
	
GAME
	;printa kartan
PRINTMAP
	LOAD #0, Gr0;
	LOAD #0, Gr1;
	
PRINTMAPLOOPX
	STORE $F00, Gr0; kopiera X och Y till in-register till TOGMEM
	STORE $F01, Gr1;
	LOAD $F00, Gr12;
	LOAD $F01, Gr13;
	LOAD #PRINTMAPRETURN, Gr14; return-adress
	BRA #TOGMEM
PRINTMAPRETURN
	;nu har vi X och Y på GMEM-form i Gr15
	LOAD #PRINTMAPRETURN2, Gr14;
	BRA #GETOBSTACLEBYGMEM
PRINTMAPRETURN2
	;nu har vi FFFF i Gr11 om det är ett hinder på pos
	GSTORE Gr11; F är tile-värdet för hinder
	ADD #1, Gr0; öka X
	CMP #32, Gr0; 
	BNE #PRINTMAPLOOPX; om vi inte är färdiga med raden
	;annars ( vi är färdiga med raden) fortsätt ner

PRINTMAPLOOPY
	LOAD #0, Gr0;
	ADD #1, Gr1;
	CMP #32, Gr1;
	BNE #PRINTMAPLOOPX; om vi inte är färdiga, fortsätt loopa
	;annars (vi är färdiga) gå vidare
	
	
;--------------------------------------GAME LOOP-------------
	
	
GAMELOOP


SNAKELOADOLD1
	;först spara positionen gamla huvudet är på. 
	LOAD $C3E, Gr0; ladda head-pointern till Gr0
	;dags att förberade subrutinkall till FROMGMEM
	LOAD $C00, Gr15, Gr0; ladda Gr15 med gamla huvudets position (Gr0 som index)
	LOAD #SNAKERETURNA, Gr14; returadress
	BRA #FROMGMEM; Lägger X, Y i Gr12, Gr13
SNAKERETURNA
	
	; nu: Gr12, Gr13 innehåller X, Y
	; ska ge dem rätt värde utifrån rörelseriktning
	
	;ta reda på SPI-data för snake 1
	;TODO FIXA JOYSTICK
	;välj direction baserat på SPI-data
	
SNAKELEFT1
	SUB #1, Gr12; minska X med 1
	BRA #SNAKESTOREHEADPOS
SNAKEUP1
	SUB #1, Gr13; minska Y med 1
	BRA #SNAKESTOREHEADPOS
SNAKERIGHT1
	ADD #1, Gr12; öka X med 1
	BRA #SNAKESTOREHEADPOS
SNAKEDOWN1
	ADD #1, Gr13; öka Y med 1
	BRA #SNAKESTOREHEADPOS
	
SNAKESTOREHEADPOS
	LOAD #SNAKERETURNB, Gr14;
	BRA #TOGMEM; formatera tillbaka till GMEM-form
SNAKERETURNB 
	;Nu ligger första ormens nya huvudposition i Gr15, formaterat för Gmem
	STORE $D00; Spara huvudets position för senare användning
	
; PASTA IN ORM2 HÄR!
	
	
	;nu ligger nya huvud-positionerna  $D00 och $D01
	;dags att flytta fram head och lägga in rätt värde på head-platsen i arraysen
	
	LOAD $C3E, Gr0; orm 1 head pointer till gr0
	ADD #1, Gr0; 
	MOD #62, Gr0; cirkulär lista. orm-array max 62 lång.
	LOAD $D00, Gr1; ladda in nya huvudpos till Gr1
	STORE $C00, Gr1, Gr0; spara nya huvudpos på huvudplatsen i orm-arrayen
	STORE $C3E, Gr0; lägg tillbaka nya huvudplatsen igen
	
;PASTA IN ORM 2 HÄR!
	
	;Dags att kolla kollision med kartan eller äpple
	
;-------------KOLLA ÄPPLE
	
	;äpple
	LOAD $D00, Gr0; ladda huvudets position till Gr0
	CMP $CC0, Gr0; jämför med äpplets position
	BNE #SNAKECHECKMAP1; om ej träff, gå vidare
	;annars (om träff) fixa äpple
	;--fixa score
	LOAD $AFD, Gr3; ladda Score till Gr3
	ADD #1, Gr3; öka med ett
	STORE $AFD, Gr3; spara tillbaka den inkrementade scoren
	;--fixa nytt äpplet
	
	
;-------------KOLLA KARTA
SNAKECHECKMAP1
	;karta
	;förbered för GETOBSTACLEBYGMEM
	LOAD $D00, Gr15; pos
	LOAD #SNAKEHITRETURN1, Gr14; returnadress
	BRA #GETOBSTACLEBYGMEM; gör kallet
SNAKEHITRETURN1
	;nu ligger det FFFF i Gr11 om det är ett hinder på pos
	CMP #$FFFF, Gr11;
	BNE #SNAKEMOVETAIL; om en hinder i vägen, gå vidare
	;annars (hinder i vägen)
	BRA #MENU; gå till menyn
	
SNAKEMOVETAIL1
	LOAD $C3F, Gr0; ladda in svanspekaren för orm 1
	LOAD $C00, Gr15, Gr0; ladda gamla svanspos tills senare
	ADD #1, Gr0; öka pekaren med ett
	MOD #62, Gr0; cirkulär array
	STORE $C3F, Gr0; lägg tillbaka igen
	
	;dags att måla tomt där svansen var
	;har redan gamla svansposen i Gr15
	GSTORE #$0000; sudda, med tile 0000

SNAKECHECKHITPLAYER1
	LOAD $C7E, Gr0; ladda andra ormens head-pointer, som loopas över
	;LOAD $C7F, Gr1; tail-pointer, som skall loopas till
	LOAD $C3E, Gr2; ladda denna orms huvud-pointer
	LOAD $C00, Gr2, Gr2; ladda denna orms huvudpos
	STORE $D00, Gr2; spara huvudpos på $D00
SNAKEHITLOOP1
	LOAD $C40, Gr3, Gr0; ladda nuvarande dels pos
	CMP $D00, Gr3; jämför current dels pos med huvudpos
	BNE #SNAKELOOPCONTINUE1; om inte träff
	BRA #MENU; annars
SNAKELOOPCONTINUE1
	;kan passa på att rita ut ormen när vi ändår loopar genom den
	LOAD $C40, Gr15, Gr0; spara cur pos i Gr15, för att rita ut till GMEM
	GSTORE #$0003; rita orm2-tile på cur pos.
	;sätt fram current-pointern och kolla slut etc
	ADD #1, Gr0;
	MOD #62, Gr0; cirkulär lista
	CMP $C7F, Gr0; Jämför nuvarande dels pointer med tailpointer
	BNE #SNAKEHITLOOP1; om inte samma, fortsätt loopa
	;annars, fortsätt programmet
	
;PASTA ORM 2 HÄR!

	
	
	
	
	
	;Kolla kollision med banan eller äpple
	;om inte äpple tagen:
	;	flytta fram tail
	;	måla tomt där tail va
	;kolla kollision mellan huvud och spelare
	;Måla orm på alla ställen mellan head och tail i arraysen
	
	







